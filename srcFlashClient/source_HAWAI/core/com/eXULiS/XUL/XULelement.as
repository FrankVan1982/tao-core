import com.eXULiS.lib.*;class com.eXULiS.XUL.XULelement extends MovieClip {	public var toolbox:Toolbox;// internals ( TODO: should be private/protected scope)	public var _exulis;	public var _objParent;	public var _objDescendants:Array;	public var _actions:Array;	public var _objDef:XMLNode;	public var _childNextDepth:Number = 1;	public var _nodeName:String = "";	public var _type:String = "";	public var _targetExecutionLayer;	public var _guiSource;	public var _visibilityState:Boolean;// dedicated to splitPane splitter balance	public var _reservedWidth:Number = 0;	public var _reservedHeighth:Number = 0;// dedicated to flex management - see flex_v7.xls for details	public var _containerWidth:Number;				// CW	public var _containerHeight:Number;							// CH	public var _numberFlex:Number = 0;						// NF	public var _labelWidth:Number; 				// LW	public var _labelHeight:Number;								// LH	public var _defaultWidth:Number;				// DW	public var _defaultHeight:Number;								// DH	public var _realWidth:Number;					// RW	public var _realHeight:Number;									// RH	public var _totalFlex:Number = 0; 						// TF	public var _flexAlreadySummed:Boolean = false;	public var _toShareRemainingWidth:Number = 0;	// TSRW	public var _toShareRemainingHeight:Number = 0;					// TSRH	public var _toShareTotalFlexWidth:Number = 0; 	// TSTFW	public var _toShareTotalFlexHeight:Number = 0;					// TSRFH	public var _toDecreaseFlexWidth:Number = 0; 	// ToDECFW	public var _toDecreaseFlex:Number = 0; 											// To Delete	public var _toDecreaseFlexHeight:Number = 0; 					// ToDECFH	public var _minFlexWidth:Number = 0; 			// MiFW	public var _minFlexHeight:Number = 0;							// MiFH	public var _maxFlexWidth:Number = 0; 			// MxFW	public var _maxFlexHeight:Number = 0;							// MxFH	public var _childsMinNeedWidth:Number = 0; 	// CMiNW	public var _childsMinNeedHeight:Number = 0;					// CMiNH	public var _nextElementFlexLeftEdge:Number = 0;// NEFLE	public var _nextElementFlexTopEdge:Number = 0;					// NEFTE// public XUL base element fundamental properties	public var id:String = "";	public var left:Number = 0;	public var top:Number = 0;	public var width:Number = 0;					// W	public var height:Number = 0;									// H	public var minwidth:Number;					// MiW	public var minheight:Number;									// MiH	private var colors:w3colors;	public var visibility:String;	function XULelement(xulParent,xulDef:XMLNode) {		_objParent = xulParent;		_objDescendants = new Array();		_objDef = xulDef;		_nodeName = _objDef.nodeName;		_type = (_nodeName.indexOf(":") == -1) ? _nodeName : _nodeName.substr(_nodeName.indexOf(":") + 1);		_targetExecutionLayer = _objParent._exulis._targetExecutionLayer;		_guiSource = _objParent._exulis._guiSource;		if(_objDef.attributes["id"] == undefined){			_objDef.attributes["id"] = _objParent._exulis.id + "_" + _type + _objParent._childNextDepth;		}		id = _objDef.attributes["id"];		colors = (_objParent._colors == undefined) ? new w3colors() : _objParent._colors; // inherit (or not) colors object				toolbox = (_objParent._toolbox == undefined) ? new Toolbox() : _objParent._toolbox; // inherit (or not) toolbox object		//		trace("XULelement (constructor): " + _type + " named " + id + " is based on " + _objParent._exulis.id);	}	function create(__obj,__creator,childNextDepth_num){//		trace("XULelement (create): " + _type + " (" + id + ") on " + _objParent + " on depth: " + _objParent._childNextDepth + " - general properties setting");		__obj = _objParent[_objDef.attributes["id"]];		__obj._childNextDepth = childNextDepth_num;		__obj._colors = colors;		__obj._toolbox = toolbox;//		__obj._objParent = _objParent;		_objParent._childNextDepth++;		setup();		__obj._exulis = __creator;//		__obj._exulis._objDefsRepository = _objParent._exulis._objDefsRepository;		return __obj;	}	function applyStyle(__obj){		if(_objDef.attributes["style"] != undefined){			var localStyle_str = new String(_objDef.attributes["style"]);			var styleWorkArray = new Array();			styleWorkArray = localStyle_str.split(";");//			trace("XULstyle: STYLE entered");			for(var vCpt=0;vCpt < styleWorkArray.length; vCpt++){				var aPropertyCouple_str:String;				var elementsArray_array:Array;				elementsArray_array = new Array();				aPropertyCouple_str = new String(styleWorkArray[vCpt]);				elementsArray_array = aPropertyCouple_str.split(":");				var propName_str:String;				var propVal_str:String;				propName_str = toolbox.trimString(elementsArray_array[0], true, true);				propVal_str = toolbox.trimString(elementsArray_array[1], true, true);				if((propVal_str != undefined) && (propVal_str != "undefined")){//					trace("XULstyle: STYLE propName_str:" + propName_str + " propVal_str:" + propVal_str);					if((propName_str == "background-color") && (propVal_str == "transparent")){						__obj.depthChild0._alpha = 0;					}					else{						if(isNaN(parseInt(propVal_str))){							__obj.setStyle(propName_str,propVal_str);						}						else{							__obj.setStyle(propName_str,parseInt(propVal_str));						}					}				}			}		}		return __obj;	}	function setup(){//		trace("XULelement (setup): parent.width:" + _objParent._exulis.width + " parent.height:" + _objParent._exulis.height);		left = (_objDef.attributes["left"] != undefined) ? parseInt(_objDef.attributes["left"]):left;		top = (_objDef.attributes["top"] != undefined) ? parseInt(_objDef.attributes["top"]):top;		width = (_objDef.attributes["width"] != undefined) ? parseInt(_objDef.attributes["width"]):width;		height = (_objDef.attributes["height"] != undefined) ? parseInt(_objDef.attributes["height"]):height;		if(_objDef.attributes["visible"] != undefined) {			visibility = _objDef.attributes.visible;			visibility = visibility.toLowerCase();		}		else {			visibility = "inherit";		}		_visibilityState = (visibility == "false") ? false : true;				// events (prototype for all events).				/*if(_objDef.attributes["oncommand"] != undefined){			if(_actions == undefined){				_actions = new Array();			}												var tmpActions_str:String = _objDef.attributes["oncommand"];			var tmpActions_array:Array = new Array();			tmpActions_array = tmpActions_str.split(";");			var tmpActionsLastIndex_num:Number = tmpActions_array.length - 1;			if(tmpActions_array[tmpActionsLastIndex_num] == ""){				tmpActions_array.length = tmpActionsLastIndex_num;			}						for(var vCpt_num:Number = 0;vCpt_num < tmpActions_array.length;vCpt_num++){				var vAction_obj:Object = {type:"command", action:tmpActions_array[vCpt_num]};				_actions.push(vAction_obj);			}		}								trace("XULelement (setup): _actions.length=" + _actions.length); */						// events (prototype for all events).				// list of possible events		var _event_type_ar:Array=["onload","oncommand","onchange"];		// for testing if an event exist		var _foundEvent_bool:Boolean=false;		var _eventsNumber_nbr:Number=_event_type_ar.length;				// test if an event attributes is on an element		for (var t=0;t<_eventsNumber_nbr;t++)		{			if (_objDef.attributes[_event_type_ar[t]] != undefined)			{				_foundEvent_bool=true;//				trace("MyEvents : "+_eventsNumber_nbr+" > type : "+_event_type_ar[t]+" attributes : "+_objDef.attributes[_event_type_ar[t]]);				break;			}					}				// event found		if(_foundEvent_bool){						// if first event create array			if(_actions == undefined){				_actions = new Array();			}						// dispatch event by type if multiple event on one element ex : onload and onchange			for (var t=0;t<_eventsNumber_nbr;t++)			{				if (_objDef.attributes[_event_type_ar[t]] != undefined)				{					var tmpActions_str:String = _objDef.attributes[_event_type_ar[t]];					var tmpActions_array:Array = new Array();					tmpActions_array = tmpActions_str.split(";");					var tmpActionsLastIndex_num:Number = tmpActions_array.length - 1;					if(tmpActions_array[tmpActionsLastIndex_num] == ""){						tmpActions_array.length = tmpActionsLastIndex_num;					}					for(var vCpt_num:Number = 0;vCpt_num < tmpActions_array.length;vCpt_num++){						var vAction_obj:Object = {type:_event_type_ar[t].substr(2), action:tmpActions_array[vCpt_num]};						_actions.push(vAction_obj);					}				}			}		}		trace("XULelement (setup): _actions.length=" + _actions.length);		/*		left = 0;		if(_objDef.attributes["left"] == undefined){										//  if left undefined then			if((_objParent._exulis._type == "hbox") || (_objParent._exulis._type == "box")){	//		if _objParent._exulis._type is hbox or box then				if(_objParent._exulis._nextElementFlexLeftEdge != undefined){					left = _objParent._exulis._nextElementFlexLeftEdge;						//				set left on _nextElementFlexLeftEdge				}			}		}		else{	left = parseInt(_objDef.attributes["left"]);}		trace("XULelement (setup): left:" + left);        top = 0;		if(_objDef.attributes["top"] == undefined){										//  if top undefined then			if((_objParent._exulis._type == "vbox") || (_objParent._exulis._type == "window") || (_objParent._exulis._type == "toolbox")){//		if _objParent._exulis._type is vbox then				if(_objParent._exulis._nextElementFlexTopEdge != undefined){					top = _objParent._exulis._nextElementFlexTopEdge;							//				set top on _nextElementFlexTopEdge				}			}		}		else{	top = parseInt(_objDef.attributes["top"]);}		trace("XULelement (setup): top:" + top);// compute minimum width & height thanks to label (if available)		var tmpMinWidth:Number = 0;		var tmpMinHeight:Number = 0;		if(_objDef.attributes["label"] != undefined){			var minWidthHeight:Object;			minWidthHeight = toolbox.evaluateLabelSize(_objDef.attributes["label"]);			tmpMinWidth = minWidthHeight.minWidth + 4;			tmpMinHeight = minWidthHeight.minHeight + 4;			trace("XULelement (setup): label w:" + tmpMinWidth + " h:" + tmpMinHeight);		}// check minwidth compared to label width; keep the widest		_minFlexWidth = ((_objDef.attributes["minwidth"] != undefined) && (parseInt(_objDef.attributes["minwidth"]) > tmpMinWidth)) ? parseInt(_objDef.attributes["minwidth"]) : tmpMinWidth;// check minheight compared to label height; keep the tallest		trace("XULDEF _objDef.attributes[minheight]: " + _objDef.attributes["minheight"]);		_minFlexHeight = ((_objDef.attributes["minheight"] != undefined) && (parseInt(_objDef.attributes["minheight"]) > tmpMinHeight)) ? parseInt(_objDef.attributes["minheight"]) : tmpMinHeight;		trace("XULDEF _minFlexHeight: " + _minFlexHeight);		delete tmpMinWidth;		delete tmpMinHeight;// check width; if bigger, we keep it		if((_objDef.attributes["width"] != undefined) && (parseInt(_objDef.attributes["width"]) > _minFlexWidth)){			_minFlexWidth = parseInt(_objDef.attributes["width"]);		}// check height; if bigger, we keep it		trace("XULDEF _objDef.attributes[height]: " + _objDef.attributes["height"]);		if((_objDef.attributes["height"] != undefined) && (parseInt(_objDef.attributes["height"]) > _minFlexHeight)){			_minFlexHeight = parseInt(_objDef.attributes["height"]);		}		trace("XULDEF _minFlexHeight: " + _minFlexHeight);////// if no default width then use parent's width//		if(_minFlexWidth == 0){//			if((_objParent._exulis.width != undefined) && (_objParent._exulis.width != 0)){//				_minFlexWidth = _objParent._exulis.width;//			}//		}//		_minFlexHeight = (_minFlexHeight == 0) ? _defaultHeight : _minFlexHeight; // ASSERT: _defaultHeight is defined for any type of component		_minFlexWidth = (_minFlexWidth == 0) ? _defaultWidth : _minFlexWidth; // ASSERT: _defaultWidth is defined for any type of component		if(((_objParent._exulis._type == "hbox") || (_objParent._exulis._type == "box")) && (_objParent._exulis._objDef.attributes["flex"] != undefined)){			_minFlexHeight = _objParent._exulis.height;		}		var expectedWidth:Number;	// EW		var expectedHeight:Number;// retrieve NF aka the number of flex of the element		_numberFlex = (_objDef.attributes["flex"] != undefined) ? Number(_objDef.attributes["flex"]) : 0;// here's what really matters for correct display of flexed elements TSTFW, TSRW and ToDECF// now we adjust width for the best fit		if((_objParent._exulis._type == "hbox") || (_objParent._exulis._type == "box")){			expectedWidth = _objParent._exulis._containerWidth * _numberFlex / _objParent._exulis._totalFlex;			_maxFlexWidth += (expectedWidth < _minFlexWidth) ? _minFlexWidth : expectedWidth - (_objParent._exulis._toShareTotalFlexWidth * _numberFlex / _objParent._exulis._toDecreaseFlex);			_realWidth = (_toShareRemainingWidth < 0) ? expectedWidth : _maxFlexWidth;			_realWidth = ((_realWidth < _minFlexWidth) && (_toShareRemainingWidth >= 0)) ? _minFlexWidth : _realWidth;//			_realWidth = ((_realWidth + left) > _objParent._exulis.width) ? _objParent._exulis.width - (left + 1) : _realWidth;			if((_realWidth + left) > _objParent._exulis.width){				trace("Réajusté W:");				 trace("RW:" + _realWidth + " Left:" + left + " parentW:" + _objParent._exulis.width);				 var v_tmp = _objParent._exulis.width - left;				 trace("new width: " + v_tmp);			}			else{				 trace("Inchangé W:");				 trace("RW:" + _realWidth + " Left:" + left + " parentW:" + _objParent._exulis.width);			}			_realWidth = ((_realWidth + left) > _objParent._exulis.width) ? _realWidth - left : _realWidth;			_realWidth = (_objParent._exulis._totalFlex == 0) ? _minFlexWidth : _realWidth;		}// and we adjust height for the best fit		if(((_objParent._exulis._type == "vbox") && (_objParent._exulis._objDef.attributes["flex"] != undefined)) || (_objParent._exulis._type == "window")){			expectedHeight = _objParent._exulis._containerHeight * _numberFlex / _objParent._exulis._totalFlex;			_maxFlexHeight += (expectedHeight < _minFlexHeight) ? _minFlexHeight : expectedHeight - (_objParent._exulis._toShareTotalFlexHeight * _numberFlex / _objParent._exulis._toDecreaseFlex);			_realHeight = (_toShareRemainingHeight < 0) ? expectedHeight : _maxFlexHeight;			_realHeight = ((_realHeight < _minFlexHeight) && (_toShareRemainingHeight >= 0)) ? _minFlexHeight : _realHeight;			if((_realHeight + top) > _objParent._exulis.height){				trace("Réajusté H:");				 trace("RH:" + _realHeight + " Top:" + top + " parentH:" + _objParent._exulis.height);				 var v_tmp = _objParent._exulis.height - top;				 trace("new height: " + v_tmp);			}			else{				 trace("Inchangé H:");				 trace("RH:" + _realHeight + " Top:" + top + " parentH:" + _objParent._exulis.height);			}			_realHeight = ((_realHeight + top) > _objParent._exulis.height) ? _realHeight - top : _realHeight;			_realHeight = (_objParent._exulis._totalFlex == 0) ? _minFlexHeight : _realHeight;		}//        width = ((_realWidth != undefined) && (_realWidth != 0)) ? _realWidth : _objParent._exulis.width;        width = ((_realWidth != undefined) && (_realWidth != 0)) ? _realWidth : _minFlexWidth;//        minwidth = (_objDef.attributes["minwidth"] != undefined) ? Number(_objDef.attributes["minwidth"]) : 0;        minwidth = (_objDef.attributes["minwidth"] != undefined) ? Number(_objDef.attributes["minwidth"]) : _minFlexWidth;		if((_type == "button") || (_type == "menubar") || (_type == "menu") || (_type == "toolbarbutton")){			height = ((_realHeight != undefined) && (_realHeight != 0)) ? _realHeight : _minFlexHeight;			minheight = (_objDef.attributes["minheight"] != undefined) ? Number(_objDef.attributes["minheight"]) : _minFlexHeight;		}		else{			height = ((_realHeight != undefined) && (_realHeight != 0)) ? _realHeight : _objParent._exulis.height;			minheight = (_objDef.attributes["minheight"] != undefined) ? Number(_objDef.attributes["minheight"]) : 100;		}		trace("XULelement (setup): " + id + "(" + _type + ") TF:" + _objParent._exulis._totalFlex + " NF:" + _numberFlex + " ToDECF:" + _objParent._exulis._toDecreaseFlex);		trace("XULelement (setup): " + id + "(" + _type + ") EW:" + expectedWidth + " MiFW:" + _minFlexWidth + " MxFW:" + _maxFlexWidth + " TSTFW:" + _objParent._exulis.toShareTotalFlexWidth + " TSRW:" + _objParent._exulis.toShareRemainingWidth + " RW:" + _realWidth);		trace("XULelement (setup): " + id + "(" + _type + ") EH:" + expectedHeight + " MiFH:" + _minFlexHeight + " MxFH:" + _maxFlexHeight + " TSTFH:" + _objParent._exulis._toShareTotalFlexHeight + " TSRH:" + _objParent._exulis._toShareRemainingHeight + " RH:" + _realHeight);		_objParent._exulis._nextElementFlexLeftEdge = left + width;		_objParent._exulis._nextElementFlexTopEdge = top + height;*/	}}