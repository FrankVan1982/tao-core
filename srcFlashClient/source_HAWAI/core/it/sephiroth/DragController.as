import it.sephiroth.DragEvent;import mx.core.UIComponent;import mx.events.EventDispatcher;import flash.display.BitmapData;import mx.transitions.Tween;import mx.transitions.easing.*[Event("dragStart")][Event("dragComplete")][Event("dragFailed")][InspectableList("dataProvider")]/** * * @author   Alessandro Crugnola, Nicolas Zeh * @version  1.0.0 [revised version of Alessandro Crugnola's DraggableController component version 1.0] **/class it.sephiroth.DragController extends UIComponent  {		/** 	* FLAGS:	* deny drag a folder.	* Each of DragController FLAG can be used associated with multiple other FLAGS	* @usage <code>import it.sephiroth.DragController	* myDragC.addReference( comp1, comp2, DragController.DENYDRAGFOLDER | DragController.DENYDROPINTOITEM );	* // or	* myDragC.addReference( comp1, comp2, DragController.DENYDRAGFOLDER, DragController.DENYDROPINTOITEM );	* </code>	*/	/** deny dragging an folder node (only tree component) */	static var DENYDRAGFOLDER:Number      	= 1;	/** deny dragging an item node (only tree component) */	static var DENYDRAGITEM:Number        	= 2;	/** deny dropping an node into an item (only tree component) */	static var DENYDROPINTOITEM:Number    	= 4;	/** deny dropping an node into an folder (only tree component) */	static var DENYDROPINTOFOLDER:Number  	= 8;	/** deny dropping an node into an item or folder (only tree component) */	static var DENYDROPINTO:Number  		= DENYDROPINTOITEM | DENYDROPINTOFOLDER;	/** deny dropping an node "in between" (i.e. before or after) an item 	  * if added to a List or DataGrid component will have the result that items will be appended to the list	  */	static var DENYDROPINBETWEEN:Number  	= 16;			/** FLAGS for setting the mouse icon 		DC.setMouseIcon( DragController.MOUSE_ADD );	*/	static var MOUSE_NORMAL:Number		= 0;	static var MOUSE_NOT_ALLOWED:Number	= 1;	static var MOUSE_ADD:Number			= 2;		// inherited methods from UIComponent	public var addEventListener:Function;	public var removeEventListener:Function;		public var setStyle:Function;	public var getStyle:Function;		private var dispatchEvent:Function;	private var onEnterFrame:Function;		private var __dataProvider:Object;		private var dc_icon:MovieClip; // DragController icon	private var _border:MovieClip;	private var _icon:MovieClip;	private var _mouse_icon:MovieClip;	private var _bmp:BitmapData;		private var __selected:Object;	private var __source:Object;	private var __target:Object;		private var __dragging:Boolean;	private var __points:Array;	private var __currentFocus :Object;			private var zeSource_str:String;	private var zeTarget_str:String;		function DragController(){				/* 			added this global object to make setting flags simple			AND in swc version of this component adding it.sephiroth.DragController.DENYDRAGFOLDER as flag			will somehow override the whole component ???			whereas when using the NOT-compiled component everything is working properly		*/				trace("myDRAG >> "+zeSource_str);				_global.DragController = {			DENYDRAGFOLDER:DENYDRAGFOLDER,			DENYDRAGITEM:DENYDRAGITEM,			DENYDROPINTOITEM:DENYDROPINTOITEM,			DENYDROPINTOFOLDER:DENYDROPINTOFOLDER,			DENYDROPINTO:DENYDROPINTO,			DENYDROPINBETWEEN:DENYDROPINBETWEEN,						MOUSE_NORMAL:MOUSE_NORMAL,			MOUSE_NOT_ALLOWED:MOUSE_NOT_ALLOWED,			MOUSE_ADD:MOUSE_ADD		};				// remove icon symbol from stage		dc_icon._visible = false;				// as we use this clip for adding dragging icons etc. 		// -> be sure that scaling is disabled and _x + _y should be no floating values (not really necessary)		// also this clip has to be at a higher depth as the components which are used for dragging		// this will lie in the hands of the user and is not that hard to accomplish		_xscale = _yscale = 100;		_x = _y = 0;				EventDispatcher.initialize(this);		__dataProvider = new Object();				setStyle('dropBorderColor', 0x666666);			}		/**	 * Add a reference between one component to another	 * The source (=from reference) has to be a valid component	 * The target (=to reference) has to at least be a MovieClip	 * @usage   	 * @param   from_mc 	 * @param   dest_mc 	 * @return  	 */	public function addReference(from_mc:MovieClip, dest_mc:MovieClip):Void{				// lowered restrictions for dest_mc from UIComponent to MovieClip		if(!(from_mc instanceof mx.core.UIComponent) || !(dest_mc instanceof MovieClip)){					return;		}				if( __dataProvider[from_mc] == undefined ){			__dataProvider[from_mc] 	= { dragflags:0, dropflags:{}, targets:{} };			from_mc.addEventListener('itemRollOver', this);			from_mc.addEventListener('itemRollOut', this);		}				__dataProvider[from_mc].targets[dest_mc] 	= dest_mc;		__dataProvider[from_mc].dropflags[dest_mc] 	= 0;				// PARSE FLAGS		// FLAGS: i.e. drag & drop options for the source and target component		// drag FLAGS will be used on the source component		// drop FLAGS will be used on the target component		var i=2, l=arguments.length;		for(i; i<l; i++) __dataProvider[from_mc].dropflags[dest_mc] |= arguments[i];		// dropflags[dest_mc] holds all flags for dropping an item to another component aimed for processing denydrop options		__dataProvider[from_mc].dragflags |= __dataProvider[from_mc].dropflags[dest_mc];	// dragflags holds all flags ever sent for the source component aimed for processing denydrag options			}		/**	 * Remove a reference from a component to another	 * @usage   	 * @param   from_mc 	 * @param   dest_mc 	 * @return  	 */	public function removeReference(from_mc:MovieClip, dest_mc:MovieClip):Void{		if( __dataProvider[from_mc] != undefined){			delete __dataProvider[from_mc].targets[dest_mc];			delete __dataProvider[from_mc].dropflags[dest_mc];		}	}		/**	 * Returns the dataProvider for a specific source (drag from) component	 * @usage   	 * @param   source 	 * @return  Object	 */	public function getDataProviderOf(source:MovieClip):Object{		return __dataProvider[source];	}		/**	 * Set the references between components	 * @usage   dataProvider = { source_component:{ dragflags:0, dropflags:{}, targets:{} } }	 * @param   dp 	 * @return  	 */	public function set dataProvider(dp:Object):Void{		__dataProvider = dp;	}	/**	 * returns dataProvider	 */	public function get dataProvider():Object{		return __dataProvider;	}	/**	 * itemRollOver Event listening method for components registered with addReference	 */	function itemRollOver(evt:Object):Void{		var item:Object = evt.target.getItemAt(evt.index);								zeSource_str=evt.target.getItemAt(evt.index).id;						if(item != undefined){			__selected = { mc:evt.target, item:item, index:evt.index };		} else {			itemRollOut();		}	}	/**	 * itemRollOut Event listening method for components registered with addReference	 */	function itemRollOut(evt:Object):Void{		__selected  = undefined;	}	/**	 * onMouseDown Event listening method	 */	function onMouseDown(){				if( __selected.mc != undefined ) {						__dragging  	= false;			__points 		= new Array( _xmouse, _ymouse);			__source 		= __selected;			onEnterFrame 	= _onEnterFrame;						// have to use interval because onMouseDown Event which sets selected Items is triggered after "this" onMouseDown method			__source.intv = setInterval( this, 'getIndices', 20 );					}			}		function getIndices(){		if( __source.mc.selectedItems ) {			__source.items		= __source.mc.selectedItems;			__source.indices	= __source.mc.selectedIndices;					}		clearInterval( __source.intv );		delete __source.intv;	}	/**	 * _onEnterFrame is set as onEnterFrame-MovieClip-Event if Mouse is pressed over an component which was registered with addReference 	 */	function _onEnterFrame(){				if( !__dragging ){ // if we are not already dragging a clip			// start dragging clip if mouse has moved at least 3px and an component (item) is selected			if( __source.mc && (Math.abs( _xmouse  - __points[0] ) > 3 || Math.abs( _ymouse - __points[1] ) > 3) ){								// check flags if dragging is allowed -> only for Tree components as deny dragging for lists would be stupid (simply add no reference)				if( __source.mc.className == "Tree" ){					var flags = __dataProvider[__source.mc].dragflags;										var parse = false, branch = false;					if(flags & DENYDRAGITEM){						parse = true;					} else if(flags & DENYDRAGFOLDER){						parse = true;						branch = true;					}										if(parse){						for(var i=0; i<__source.items.length; i++){							if( branch == __source.mc.getIsBranch( __source.items[i] ) ){								__source.items.splice( i, 1 );								__source.indices.splice( i, 1 );								i--;							}						}					}										i = __source.items.length-1;					// if no item is left in selection					if( i < 0 ){						onDragVeto();						return;					} else {						__source.item 	= __source.items[i];						__source.index 	= __source.indices[i];					}				} // end if Tree								_CreateDraggingIcon( __source.mc, __source.index, __source.indices );																clearInterval( __source.mc.dragScrolling );				__source.mc.clearSelected(false);								__currentFocus 	= undefined;				__dragging   	= true;								// added Veto method in here to dissallow dragging on user specified function				var evt:DragEvent 	= new DragEvent( this );				evt.type 			= 'dragStart';				evt.sourceComponent = __source.mc;				evt.sourceItem      = __source.item;				evt.sourceIndex     = __source.index;				evt.sourceItems     = __source.items;				evt.sourceIndices   = __source.indices;								trace("feedTrace for MAIL_DRAG, Stimulus " + "id"+_root.FEEDTRACE_PAYLOAD_ATTRIBUTE_NAME_VALUE_SEPARATOR+zeSource_str);				_level0.currentItemRootLevel.feedTrace("MAIL_DRAG","id"+_root.FEEDTRACE_PAYLOAD_ATTRIBUTE_NAME_VALUE_SEPARATOR+zeSource_str,"stimulus");								dispatchEvent(evt);							}				// if we are already dragging a clip		} else if( __dragging ) {						__target = undefined; // we got no target yet			_ClearDropBorder();						var point:Object = { x:_parent._xmouse, y:_parent._ymouse };			_parent.localToGlobal( point );						// check defined targets if there is a possible drag target at the current mouse position			var a, hit=false, mouse_icon=MOUSE_NOT_ALLOWED, dest_mc:MovieClip = __dataProvider[__source.mc].targets;						for(a in dest_mc){								// there is a possible drag target -> save it in "__target" object for onMouseUp event				if( dest_mc[a].hitTest( point.x, point.y, true ) ){										if( dest_mc[a] != __currentFocus ) {												_ActivateFocus(dest_mc[a], true);						__currentFocus = dest_mc[a];						// do further processing on next onEnterFrame -> then focus is set properly											} else {												var flags = __dataProvider[__source.mc].dropflags[dest_mc[a]];												switch( dest_mc[a].className ){													case( 'Tree' ):							case( 'DataGrid' ):							case( 'List' ):														trace("by here 1");															if( dest_mc[a].selectedItem != __source.item ) { // dissallow dragging into the same item																	__target = { mc:dest_mc[a], item:dest_mc[a].selectedItem, index:dest_mc[a].selectedIndex };																	zeTarget_str=dest_mc[a].selectedItem.attributes.id;																																													// this method might change __target.item and __target.index settings due to selection									mouse_icon = _DrawDropBorder( flags ); 																	} // end if same item								break;														case( 'TextInput' ):							case( 'TextArea' ):							default:								// dissallow dragging into the same item. Currently not neccessary cause dragging from TextInput, TextArea is not supported								if( __source.mc != dest_mc[a] ){									__target = { mc:dest_mc[a], item:undefined, index:-1 };									mouse_icon = MOUSE_NORMAL;								}								break;													} // end switch												// place for possible "drag_over" Event comparing olditem/-index with newitem/-index						// but "drag_over" Event would be expensive 											} // endif __currentFocus										hit = true;					break;									}							} // end for						if( !hit ) { 				_ActivateFocus(__currentFocus, false); 				__currentFocus=undefined;			}						setMouseIcon( mouse_icon );					} // end if dragging			}		/**	 * onMouseUp Event listening method	 */	function onMouseUp(){						trace("DragController onMouseUp");				if(__dragging){						stopDrag();						var evt:DragEvent 	= new DragEvent( this );			evt.sourceComponent = __source.mc;			evt.sourceItem      = __source.item;			evt.sourceIndex     = __source.index;			evt.sourceItems     = __source.items;			evt.sourceIndices   = __source.indices;			evt.targetComponent = __target.mc;			evt.targetItem      = __target.item;			evt.targetIndex     = __target.index;						if( __source.index != undefined && __target.mc != undefined ){								__source.mc.clearSelected(false);								// added Event Method for receiving Objects itsself in here				if( evt.targetComponent.onDropData instanceof Function ) evt.targetComponent.onDropData( evt );								// moveMail				var myMCRef=evt.targetComponent._parent;								trace("feedTrace for MAIL_DROP, Stimulus, target"+_root.FEEDTRACE_PAYLOAD_ATTRIBUTE_NAME_VALUE_SEPARATOR+zeTarget_str);				_level0.currentItemRootLevel.feedTrace("MAIL_DROP","target"+_root.FEEDTRACE_PAYLOAD_ATTRIBUTE_NAME_VALUE_SEPARATOR+zeTarget_str,"stimulus");								trace("feedTrace for MAIL_MOVED, Stimulus > "+"id"+_root.FEEDTRACE_PAYLOAD_ATTRIBUTE_NAME_VALUE_SEPARATOR+zeSource_str+				_root.FEEDTRACE_PAYLOAD_ATTRIBUTES_SEPARATOR + "target"+_root.FEEDTRACE_PAYLOAD_ATTRIBUTE_NAME_VALUE_SEPARATOR+zeTarget_str);				_level0.currentItemRootLevel.feedTrace("MAIL_MOVED","id"+_root.FEEDTRACE_PAYLOAD_ATTRIBUTE_NAME_VALUE_SEPARATOR+zeSource_str+				_root.FEEDTRACE_PAYLOAD_ATTRIBUTES_SEPARATOR + "target"+_root.FEEDTRACE_PAYLOAD_ATTRIBUTE_NAME_VALUE_SEPARATOR+zeTarget_str,"stimulus");								trace("myDRAG src -> "+zeSource_str);				trace("myDRAG trg -> "+zeTarget_str);								if (zeSource_str==undefined || zeTarget_str==undefined)				{					var opt:String = new String();					if (zeSource_str != undefined)						opt = "source"+_root.FEEDTRACE_PAYLOAD_ATTRIBUTE_NAME_VALUE_SEPARATOR+zeSource_str;					else						opt = "target"+_root.FEEDTRACE_PAYLOAD_ATTRIBUTE_NAME_VALUE_SEPARATOR+zeTarget_str;					//trace("feedTrace for MAIL_MOVED_CANCEL, Stimulus > " + opt);					//_level0.currentItemRootLevel.feedTrace("MAIL_MOVED_CANCEL",opt,"stimulus");				} else				{					myMCRef._exulis.fileSystm.fileSystModel.moveItem(zeSource_str,zeTarget_str);				}								evt.type = 'dragComplete';				dispatchEvent(evt);							} else {								evt.type = 'dragFailed';				dispatchEvent(evt);							}						evt.veto(); // will do veto action if not skip or veto was called during dispatchEvent						_ClearDropBorder();			_DeleteFocus(__source.mc);					} else {			_ReleaseMouse(); // ??? necessary		}				__selected  = undefined;		__target  	= undefined;		__source	= undefined;				setMouseIcon( MOUSE_NORMAL );				delete onEnterFrame;	}		/**	 * draws a border indicating where an item will be dropped and resets __target.index and/or __target.item due to Mouse position	 * see _onEnterFrame function on info when it will be triggered	 * returns the type of mouse icon to be used	 * @usage 	 * @param Number flags (gets flags for targetComponent passed by _onEnterFrame function)	 * @return  	 */	private function _DrawDropBorder( flags:Number ):Number{				var item = _GetItemFromIndex(__target.mc,__target.index); // return the item MovieClip if there is one (depends on component)		if( !item ) return;				var gb:Object   = item.getBounds(this);		var gb_2:Object = item.getBounds(item.owner);				if(gb_2.yMax < item.owner._height){						_border = this.createEmptyObject("_border", 5);			_border.beginFill( getStyle('dropBorderColor'), 100 );			_border.drawRect( 0, 0, Math.floor( item.owner.width - item.owner.vSB.width-4 ), 1 );			_border.endFill();						_border._visible 	= false;			_border._x 			= gb.xMin;						var top, bot, disallowBetw 	= flags & DENYDROPINBETWEEN;			top = bot = item.bG_mc._height/2;					if(item.owner.className == "Tree"){								var isFolder 		= __target.mc.getIsBranch( __target.item );				var disallowInto 	= ( (flags & DENYDROPINTOITEM && !isFolder) || (flags & DENYDROPINTOFOLDER && isFolder) );								if( !disallowInto ){ // reset borders to leave enough space for "drop into"					top -= item.bG_mc._height/4;					bot += item.bG_mc._height/4;				}								// insert after // flags & DENYDRAGFOLDER && 				if( !disallowBetw && item._ymouse >= bot ){					_border._y 		= Math.floor( gb.yMin + item.bG_mc._height );					_border._visible= true;										__target.index = 0;					__target.item  = __target.item.parentNode;										// get real index					for(var i=0,l=__target.item.childNodes.length; i<l; i++){						if( __target.item.childNodes[i] == item.node ){							__target.index = i+1;							break;						}					}										return MOUSE_NORMAL;								// insert before				} else if( !disallowBetw && item._ymouse < top ) {										_border._y 			= Math.ceil( gb.yMin );					_border._visible 	= true;										__target.index = 0;					__target.item  = __target.item.parentNode;										// get real index (i.e. list not tree index), not overall index					for(var i=0,l=__target.item.childNodes.length; i<l; i++){						if( __target.item.childNodes[i] == item.node ){							__target.index = i;							break;						}					}										return MOUSE_NORMAL;									// insert into -> will add item at the end of the list				} else if( !disallowInto ){										__target.index = __target.item.childNodes.length;					return MOUSE_ADD;									}						// else if not Tree component			// => only drop inBetween is possible -> if not allowed don't process further			// makes not really sense to add this flag for non trees, but to be parsed correctly it is added here			// AT: YES makes sense: in this case the dropped item has to be added at the end of the list			} else { 								// insert after				if( !disallowBetw && item._ymouse >= bot ){					_border._y 			= gb.yMin + item.bG_mc._height;					_border._visible	= true;					__target.index++; // increase __target.index => insert after					return MOUSE_NORMAL;								// insert before				} else if (!disallowBetw && item._ymouse < top ){					_border._y 			= gb.yMin;					_border._visible	= true;					return MOUSE_NORMAL;									}								// if no inserting inbetween is allowed -> add item at the end of the list:				if( __target.mc.__dataProvider.childNodes != undefined ){					__target.index = __target.mc.__dataProvider.childNodes.length;					__target.item = __target.mc.__dataProvider.childNodes[ __target.index-1 ];				} else {					__target.index = __target.mc.__dataProvider.length;					__target.item = __target.mc.__dataProvider[ __target.index-1 ];				}				return MOUSE_ADD;							}					} // end if gb_2.yMax < item.owner._height				// if no dropping was allowed -> delete __target (so mouse cursor will show dissallow symbol)		// this can only occur with Trees. In case of Lists + DataGrids the item will be added at the end		__target = undefined;		return MOUSE_NOT_ALLOWED;			}		/**	 * clears all drawn borders which were added to indicated where an item will be dropped	 * @usage 	 * @return  	 */	private function _ClearDropBorder(Void):Void{		_border.removeMovieClip();	}	/**	 * returns the item-MovieClip at index "index" of the source_component (i.e. the component where is dragged from)	 * @usage 	 * @param index Number	 * @return  	 */	private function _GetSourceItem(index:Number):MovieClip{		return _GetItemFromIndex( __source.mc, index );	}	/**	 * returns the item-MovieClip at index "index" of the component "source" 	 * @usage 	 * @param MovieClip source	 * @param index Number	 * @return  	 */	 private function _GetItemFromIndex(source:MovieClip, index:Number):MovieClip{		if( source ){			var lastPosition = source.lastPosition || 0;			return source.rows[index-lastPosition];		}		return null;	}	/**	 * removes focus from the all components that are referenced by "source"	 * @usage 	 * @param MovieClip source	 * @return  	 */	private function _DeleteFocus(source:MovieClip):Void{		if(source){			var items = __dataProvider[source];			for(var a in items){				items[a].drawFocus(0);				items[a].clearSelected(false);			}			// TODO: Da verificare			//getFocusManager().setFocus(null)		}	}	/**	 * if param value=true: sets the focus on the component specified with param mc and sets the focus on an component's item due to mouse position	 * if param value=false: removes focus from the component specified with param mc and deselects all items	 * @usage 	 * @param MovieClip mc	 * @param Boolean value	 * @return  	 */	private function _ActivateFocus(mc:Object, value:Boolean):Void{		if(value){			getFocusManager().setFocus(mc);			mc.pressFocus();			mc.drawFocus(1);			if( mc.rows != undefined ){				for(var i=0; i<mc.rowC; i++){					if( mc._ymouse < mc.rows[i]._y ) break;				}				i = ( i>0 ) ? i-1 : 0;				mc.onRowPress( i );			}		} else {			mc.clearSelected(false);			clearInterval(mc.dragScrolling);			mc.getFocusManager().setFocus(null); // remove current focus		}	}	// private function GetFocus : a) not used in class b) getFocus method already in Class as extending UIComponent	// --> removed	// function _GetFocusManager : getFocusManager method already in Class as extending UIComponent (why the same method twice ?)	// --> removed --> use getFocusManager instead	/**	 * creates a bitmap copy of the MovieClip specified with "item" to be used for dragging	 * @usage 	 * @param MovieClip item 	 * @return  	 */ 	private function _CreateDraggingIcon( source_mc:MovieClip, index, indices ):Void{				_icon         = _root.createEmptyMovieClip("_icon", 10);		_icon.target  = this;		_icon._alpha  = 60;				var item = _GetItemFromIndex( source_mc, index );		item.setState( 'selected', false ); // set item selected for copy (just for aesthetical reason)				var mov  = _icon.createEmptyMovieClip('m', 9);		_bmp = new BitmapData(item._width,item._height, true, 0xFFFFFF);		mov.attachBitmap(_bmp, 1);		_bmp.draw(item);				var x = item._x, y = item._y;				var n = indices.length;		if( n ){			for(var i=0; i<n; i++){								if( index == indices[i] ) continue;								item = _GetItemFromIndex( source_mc, indices[i] );				item.setState( 'selected', false ); // set item selected for copy (just for aesthetical reason)								mov  = _icon.createEmptyMovieClip('m'+i, 10+i);				_bmp = new BitmapData(item._width,item._height, true, 0xFFFFFF);				mov.attachBitmap(_bmp, 1);				_bmp.draw(item);				// set x y positions				mov._x = item._x - x;				mov._y = item._y - y;			}		}				_icon.startDrag(true);	}	/**	 * sets the MouseIcon: wether to show the normal mouse icon (type=MOUSE_NORMAL or type=undefined)	 * or show the "dropping not allowed"-Icon (type=MOUSE_NOT_ALLOWED)	 * or show the "drop into"-Icon (type=MOUSE_ADD);	 * @usage 	 * @param Number static class Flag MOUSE_NORMAL | MOUSE_NOT_ALLOWED | MOUSE_ADD	 * @return  	 */	private function setMouseIcon( type:Number ):Void{				if( type>MOUSE_NORMAL ){						if(_mouse_icon == undefined){				//_mouse_icon = this.createEmptyMovieClip("_mouse_icon", 20);				_mouse_icon = _root.attachMovie("mouse_dragging_icon", "_mouse_icon", 20);				_mouse_icon.onMouseMove = function(){					this._x = this._parent._xmouse;					this._y = this._parent._ymouse;					updateAfterEvent();				}				_mouse_icon.gotoAndStop(1);				_mouse_icon.onMouseMove(); // set position				Mouse.hide();			}						if( type==MOUSE_ADD && _mouse_icon._currentframe != 2){				_mouse_icon.gotoAndStop(2);				Mouse.show();						} else if( type==MOUSE_NOT_ALLOWED && _mouse_icon._currentframe != 1 ){				_mouse_icon.gotoAndStop(1);				Mouse.hide();			}					} else if(_mouse_icon){						_mouse_icon.removeMovieClip();			_mouse_icon = undefined;			Mouse.show();					}			}	/**	 * Will Move the "dragged_item" MovieClip (i.e. the bitmap copy) back to source_item if source_item is defined.	 * Otherwise the "dragged_item" MovieClip will simply be removed	 * @usage 	 * @param MovieClip source_item (optional) 	 * @return  	 */	private function _ReleaseMouse( source_item ):Void{		trace("MYTEST : ok0 "+source_item);		if( !_icon ) return;				if( source_item != undefined ){		trace("MYTEST : ok1"+_icon);						_bmp.dispose();			_icon.removeMovieClip();					}			}	/**	 * On "start_drag" Event: If called it will prevent dragging of source_item	 * @usage   	 * @return  	 */	public function onDragVeto():Void{		_ReleaseMouse();		setMouseIcon( MOUSE_NOT_ALLOWED );		__dragging = false; // no Actions on onMouseUp		delete onEnterFrame;	}	/**	 * On "drag_complete" Event: if Drop item is Vetoed, restore source item position	 * @usage   	 * @param   evt 	 * @return  	 */	public function onDropVeto(evt:Object):Void{		var source_item = _GetItemFromIndex(evt.sourceComponent, evt.sourceIndex);		_ReleaseMouse( source_item );	}			private function onDropSkip():Void{		_ReleaseMouse();	}	/**	 * returns a copy of the source_item formated as XML or Object due to the target components requirements	 * labelName sets the following:	 * e.g. if source component is a DataGrid, you can set with labelName which column will be used as label to be inserted in other components	 *	 * if asXML=true && obj=XMLNode returns a cloned XMLNode	 * if asXML=true && obj=Object returns a new XMLNode	 * if asXML=false && obj=XMLNode returns a new Object of XMLNode attributes	 * if asXML=false && obj=Object returns a copy of obj 	 * @usage   	 * @param   Object obj the sourceItem (XMLNode or Object)	 * @param   Object mappings (optional) 	 * @param   Boolean asXML (optional)	 * @return Object XMLNode or Object depending if param asXML was true 	 */	private function _getItemValue( obj, mappings, asXML ):Object{				var i, ret, xml = (obj instanceof XMLNode);				if( asXML ){						if( xml ){				ret = obj.cloneNode(true);				for( i in mappings ){ 					if( ret.attributes[i] ){						ret.attributes[ mappings[i] ] = ret.attributes[i];						delete ret.attributes[i];					}				}			} else {				ret = new XMLNode(1, 'node');				for( i in obj ){ 					if( mappings[i] )						ret.attributes[ mappings[i] ] = obj[i];					else						ret.attributes[i] = obj[i];				}			}				} else {						if( xml ) obj = obj.attributes;						ret = new Object();			for( i in obj ){				if( mappings[i] )					ret[ mappings[i] ] = obj[i];				else					ret[i] = obj[i];			}					}				return ret;			}		/**	 * will be triggered from dragging Event Handlers. I.e. if addEventListener("drag_complete", xxx) was specified	 * 	 * @usage   	 * @param   Object evt	 * @param	String labelName (optional) 	 * @return Boolean 	 */	private function onAddItems(evt:Object, mappings, multiple:Boolean ):Boolean{				if( evt.sourceItem == undefined && (evt.sourceComponent.className=='TextInput' || evt.sourceComponent.className=='TextArea') )			evt.sourceItem = { text:evt.sourceComponent.text, label:evt.sourceComponent.text };				if( !evt.sourceItem && !evt.sourceItems  ){			onDropVeto(evt);			return false;		}				if( evt.sourceItems && multiple ){			// sort items by index (as they are sorted in order they were selected)			// --> items are inserted in target component in same order as in source component			var items 	= new Array();			for( var i=0, n=evt.sourceIndices.length; i<n; i++)				items.push( { index:evt.sourceIndices[i], item:evt.sourceItems[i] } );			items.sortOn('index');					} else {			var items = [ { index:evt.sourceIndex, item:evt.sourceItem } ];		}				switch( evt.targetComponent.className ){						case( 'Tree' ):				for( var i=0, n=items.length; i<n; i++){					var v = _getItemValue( items[i].item, mappings, 1 );					if( evt.targetIndex == undefined )						evt.targetComponent.addTreeNode( v );					else						evt.targetItem.addTreeNodeAt( evt.targetIndex + i, v );				}				break;						case( 'DataGrid' ):			case( 'List' ):						trace("by here 2");							for( var i=0, n=items.length; i<n; i++){					var v = _getItemValue( items[i].item, mappings );					if( evt.targetIndex == undefined )						evt.targetComponent.addItem( v );					else						evt.targetComponent.addItemAt(evt.targetIndex + i, v );										}				break;						case( 'TextInput' ):			case( 'TextArea' ):				for( var i=0, n=items.length, a = new Array(); i<n; i++){					var v = _getItemValue( items[i].item, mappings );					a.push( v.label );				}				if( evt.targetComponent.text ) evt.targetComponent.text += newline;				evt.targetComponent.text += a.join( newline );				break;						default:				onDropVeto(evt);				return false;					}				if( !evt.isAdded ){			evt.isAdded = true;			evt.targetComponent.refresh();			onDropSkip();		}		return true;			}		private function onRemoveItems(evt:Object, multiple:Boolean ):Boolean{				if( !evt.sourceItem && !evt.sourceItems  ){			onDropVeto(evt);			return false;		}				var items 	= evt.sourceItems && multiple 		? evt.sourceItems : [ evt.sourceItem ];		var indices = evt.sourceIndices && multiple 	? evt.sourceIndices : [ evt.sourceIndex ];				switch( evt.sourceComponent.className ){					case( 'Tree' ):				for( var i=0, n=indices.length; i<n; i++)					items[i].removeTreeNode();				break;						case( 'DataGrid' ):			case( 'List' ):						trace("by here 3");							indices.sort();				var add_i = 0;				if( evt.isAdded && evt.sourceComponent == evt.targetComponent && evt.targetIndex < evt.sourceIndex ){					add_i = indices.length;				}								for( var i=indices.length-1, a; i>-1; i--) {					a = indices[i] > evt.targetIndex ? add_i : 0;					evt.sourceComponent.removeItemAt( indices[i] + a );				}				break;						case( 'TextInput' ):			case( 'TextArea' ):				evt.sourceItem = { text:evt.sourceComponent.text };				evt.sourceItem.label = evt.sourceItem.text;				evt.sourceComponent.text = '';				break;						default:				onDropVeto(evt);				return false;					}				if( !evt.isRemoved ){			evt.isRemoved = true;			evt.sourceComponent.refresh();			onDropSkip();		}		return true;			}		private function onTransferItems(evt:Object, mappings, multiple:Boolean):Boolean{				if( !onAddItems(evt, mappings, multiple) ) return false;		return onRemoveItems(evt, multiple);			}	}